//TOP LEVEL MODULE FOR AXI4 PROJECT

module Top_Module_AXI4#(
						parameter  data_wid   = 32,
						parameter  adr_wid    = 32,
						parameter  id_wid     = 4,
						parameter  len_wid    = 4,
						parameter  siz_wid    = 3,
						parameter  bst_wid    = 2,
						parameter  loc_wid    = 2,
						parameter  cach_wid   = 2,
						parameter  prot_wid   = 3,
						parameter  strb_wid   = (data_wid/8),
						parameter  rsp_wid    = 2
								)
								
						
						( 

                //INPUT PORT DECLARATION
                 input                   clk,
                 input                   rstn,
				 input                   ACLK,
				 input                   ARESETn,
				 input                   wr_en,
                 input                   rd_en,
                 input [127:0]           wr_data,
                 input                   AWREADY_a,
                 input                   WREADY_a, 
                 input                   ARREADY_a,
                 input [id_wid-1:0]      RID_a,
                 input [data_wid-1:0]    RDATA_a,	
                 input [rsp_wid-1:0]     RRESP_a, 			
                 input                   RLAST_a, 
                 input                   RVALID_a,
				 input [id_wid-1:0]      BID_a,
                 input [rsp_wid-1:0]     BRESP_a, 			
                 input                   BVALID_a,

                 //OUTPUT PORT DECLARATION
						
                 output [id_wid-1:0]      AWID_a, 
                 output [adr_wid-1:0]     AWADDR_a,
                 output [len_wid-1:0]     AWLEN_a, 				
                 output [siz_wid-1:0]     AWSIZE_a,
                 output [bst_wid-1:0]     AWBURST_a, 
                 output [loc_wid-1:0]     AWLOCK_a, 
                 output [cach_wid-1:0]    AWCACHE_a,
                 output [prot_wid-1:0]    AWPROT_a, 
                 output                   AWVALID_a,
                 output [id_wid-1:0]      ARID_a,
                 output [adr_wid-1:0]     ARADDR_a,
                 output [len_wid-1:0]     ARLEN_a, 				
                 output [siz_wid-1:0]     ARSIZE_a,
                 output [bst_wid-1:0]     ARBURST_a, 
                 output [loc_wid-1:0]     ARLOCK_a,
                 output [cach_wid-1:0]    ARCACHE_a,
                 output [prot_wid-1:0]    ARPROT_a, 
                 output                   ARVALID_a,				 
                 output [id_wid-1:0]      WID_a,
                 output [data_wid-1:0]    WDATA_a, 
                 output [strb_wid-1:0]    WSTRB_a, 
                 output                   WLAST_a,  
                 output                   WVALID_a, 
                 output                   RREADY_a,
				 output                   BREADY_a,
				 output [127:0]           rd_data,    	
				 output                   full,
                 output                   empty
				 ); 
				 
                 //SIGNAL FOR FIFO-DECODER
				 wire          FIFO_EMPTY;
                 wire          FIFO_FULL;
                 wire          WRITE_ENABLE; 				 
                 wire  [127:0] WRITE_DATA; 
                 wire          READ_ENABLE;
				 wire  [127:0] READ_DATA;
				 
				 //SIGNAL FOR DECODER-AXI4 MASTER
				 wire                    wr_trn_en;			  
				 wire                    rd_trn_en;
				 wire                    wr_rsp_en;			  
				 wire                    rd_rsp_en;
				 wire  [adr_wid-1:0]     awaddr; 
                 wire  [(id_wid)-1:0]    txn_id_w;				 
                 wire  [bst_wid-1:0]     awburst;
				 wire  [siz_wid-1:0]     awsize;
				 wire  [(len_wid)-1:0]   awlen;
				 wire  [loc_wid-1:0]     awlock;
				 wire  [cach_wid-1:0]    awcache;
				 wire  [prot_wid-1:0]    awprot;
				 wire  [adr_wid-1:0]     araddr;
                 wire  [(id_wid)-1:0]    txn_id_r;		 
				 wire  [(len_wid)-1:0]   arlen;
				 wire  [bst_wid-1:0]     arburst;          
				 wire  [siz_wid-1:0]     arsize;
				 wire  [loc_wid-1:0]     arlock;
				 wire  [cach_wid-1:0]    arcache;
				 wire  [prot_wid-1:0]    arprot;
				 wire  [data_wid-1:0]    wdata; 
                 wire  [strb_wid-1:0]    wstrb;				 				
				 wire  [data_wid-1:0]    rdata; 
				 wire  [(id_wid)-1:0]    rid;
				 wire  [rsp_wid-1:0]     rresp;
                 wire                    rlast;				 
				 wire  [rsp_wid-1:0]     bresp;
				 wire  [id_wid-1:0]      bid;
                 wire                    write_data;
				 wire                    wvalid_d;

				 
// INSTANTIATION OF WRITE FIFO 
design_fifo DUT_FIFO (
						.clk          (clk),
						.rst          (rstn),
						.wr_en        (wr_en),
					    .wr_data      (wr_data),
					    .full         (full),							
					    .FIFO_EMPTY   (FIFO_EMPTY),
					    .READ_DATA    (READ_DATA),
					    .READ_ENABLE  (READ_ENABLE),
				        .rd_en        (rd_en),
				        .rd_data      (rd_data),
				        .empty        (empty),								
				        .FIFO_FULL    (FIFO_FULL),
				        .WRITE_ENABLE (WRITE_ENABLE),
				        .WRITE_DATA   (WRITE_DATA)
				    );
				   

//INSTANTIATION OF DECODER
my_decoder decoder (
                    .clk          (clk),
                    .rst_n        (rstn),										
                    .fifo_empty   (FIFO_EMPTY),
                    .fifo_full    (FIFO_FULL),
                    .fifo_rdata   (READ_DATA),
            	    .read_enable  (READ_ENABLE),
					.fifo_wdata   (WRITE_DATA),	
	                .write_enable (WRITE_ENABLE),					                    
		            .write_data   (write_data),								  
				    .bresp        (bresp),
                    .bid          (bid),
					.rid          (rid),
                    .rdata        (rdata),
                    .rresp        (rresp),
					.rlast        (rlast),
                    .wr_rsp_en    (wr_rsp_en),
		            .rd_rsp_en    (rd_rsp_en),
                    .awaddr       (awaddr),
                    .txn_id_w     (txn_id_w),
                    .awburst      (awburst),
                    .awlen        (awlen),
                    .awsize       (awsize),
                    .awlock       (awlock),
                    .awcache      (awcache),
                    .awprot       (awprot),
                    .wdata        (wdata),
                    .wstrb        (wstrb),
                    .wvalid       (wvalid_d),					
                    .araddr       (araddr),
                    .txn_id_r     (txn_id_r),
                    .arburst      (arburst),
		            .arlen        (arlen),
		            .arsize       (arsize),  
		            .arlock       (arlock),
                    .arcache      (arcache),
                    .arprot       (arprot),
		            .wr_trn_en    (wr_trn_en),
		            .rd_trn_en    (rd_trn_en)                            
		   );
				   
// INSTANTIATION OF AXI_MASTER
AXI_Master      #(.addr_width(32), .data_width(64))
						
						DUT_axi (
								
                    .AClk         (ACLK),
                    .ARstn        (ARESETn),
					
                    .AWID         (AWID_a),
                    .AWADDR       (AWADDR_a),
                    .AWLEN        (AWLEN_a),
                    .AWSIZE       (AWSIZE_a),
                    .AWBURST      (AWBURST_a),
                    .AWVALID      (AWVALID_a),
                    .AWREADY      (AWREADY_a),
                    .AWLOCK       (AWLOCK_a),
                    .AWCACHE      (AWCACHE_a),
                    .AWPROT       (AWPROT_a), 
					
                    .WID          (WID_a),   
                    .WSTRB        (WSTRB_a),
                    .WDATA        (WDATA_a),
                    .WLAST        (WLAST_a),
                    .WVALID       (WVALID_a),
                    .WREADY       (WREADY_a),
					
                    .BID          (BID_a),
                    .BRESP        (BRESP_a),
                    .BVALID       (BVALID_a),
                    .BREADY       (BREADY_a),
                    
                    .ARID         (ARID_a),
                    .ARADDR       (ARADDR_a),
                    .ARLEN        (ARLEN_a),
                    .ARSIZE       (ARSIZE_a),
                    .ARBURST      (ARBURST_a),
                    .ARVALID      (ARVALID_a),
                    .ARLOCK       (ARLOCK_a),
                    .ARCACHE      (ARCACHE_a),
                    .ARPROT       (ARPROT_a),
                    .ARREADY      (ARREADY_a), 
					
                    .RID          (RID_a),
                    .RDATA        (RDATA_a),
                    .RRESP        (RRESP_a),
                    .RLAST        (RLAST_a),
                    .RVALID       (RVALID_a),
                    .RREADY       (RREADY_a), 
					
                    .TXN_ID_W_d   (txn_id_w),
                    .awaddr_d     (awaddr),
                    .awlen_d      (awlen),
                    .awsize_d     (awsize),
                    .awburst_d    (awburst),
                    .awlock_d     (awlock),
                    .awcache_d    (awcache),
                    .awprot_d     (awprot),
					
                    .wdata_d      (wdata),
                    .wstrb_d      (wstrb),
					.wvalid_d     (wvalid_d),
					
                    .bresp_d      (bresp),
                    .bid_d        (bid),
                    .wr_rsp_en_d  (wr_rsp_en),
                    .wr_trn_en    (wr_trn_en), 
					
                    .TXN_ID_R_d   (txn_id_r),
                    .araddr_d     (araddr),
                    .arlen_d      (arlen),
                    .arsize_d     (arsize),
                    .arburst_d    (arburst),
                    .arlock_d     (arlock),
                    .arcache_d    (arcache),
                    .arprot_d     (arprot),
					
                    .rdata_d      (rdata),
                    .rresp_d      (rresp),
                    .rid_d        (rid),
                    .rd_rsp_en_d  (rd_rsp_en),
					.r_last_d	  (rlast),
                    .rd_trn_en    (rd_trn_en)
						  
                            
                 );
					  
					  
					  
endmodule
				 
                 				   
				 

--------------------------------------------------------------------



`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company					:	  Mirafra Technologies	 
// Engineer					:    P Shankar sharama
// 
// Create Date				:    11:49:14 07/26/2022 
// Design Name				: 	  AXI4 Master 
// Module Name				:    AXI_Master_Top 
// Project Name			: 
// Target Devices			: 	  
// Tool versions			: 
// Description				: 
//
// Dependencies			: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module AXI_Master #(parameter  addr_width=32, 
                    parameter  data_width=32
						  )      ///////
						 (
						   /////////AXI Global signals clock and reset
                     input							AClk,
							input							ARstn,
							
							/////////////AXI Write Address signals
							output	[3	:	0]								AWID,
							output	[addr_width-1	:	0]				AWADDR,
							output	[3	:	0]								AWLEN,
							output	[2	:	0]								AWSIZE,
							output	[1	:	0]								AWBURST,
							output											AWVALID,
							input											AWREADY,
							output	[1	:	0]								AWLOCK,
							output	[1	:	0]								AWCACHE,
							output	[2	:	0]								AWPROT,
							
							////////AXI Write Data channel signals
							output	[3	:	0]								WID,   
							output	[3	:	0]								WSTRB,
							output	[data_width-1	:	0]				    WDATA,
							output											WLAST,
							output											WVALID,
							input											WREADY,
							
							/////////AXI Write Response  channel signals
							input		[3	:	0]							BID,
							input		[1	:	0]							BRESP,
							input											BVALID,
							output											BREADY,
							
							/////////AXI READ CHannel signals
							output	[3	:	0]								ARID,
							output	[addr_width-1	:	0]				    ARADDR,
							output	[3	:	0]								ARLEN,
							output	[2	:	0]								ARSIZE,
							output	[1	:	0]								ARBURST,
							output											ARVALID,
							output	[1	:	0]								ARLOCK,
							output	[1	:	0]								ARCACHE,
							output	[2	:	0]								ARPROT,
							input											ARREADY,
							
							/////////AXI READ Data signals
							input		[3	:	0]							RID,
							input		[data_width-1	:	0]				RDATA,
							input		[1	:	0]							RRESP,
							input											RLAST,
							input											RVALID,
							output											RREADY,
							
							////////////Decoder Interface   
																		//////////write control and data from decoder
							input		[3	:	0]							TXN_ID_W_d,
							input		[addr_width-1	:	0]				awaddr_d,
							input		[3	:	0]							awlen_d, 
							input		[2	:	0]							awsize_d,
							input		[1	:	0]							awburst_d,
							input		[1	:	0]							awlock_d,
							input		[1	:	0]							awcache_d,
							input		[2	:	0]							awprot_d,
							
							input		[data_width-1	:	0]				wdata_d,
						    input		[3	:	0]							wstrb_d,
							input                                           wvalid_d,
							
							output	[1	:	0]								bresp_d,
							output	[3	:	0]								bid_d,
							//output                                          bvalid,
							output											wr_rsp_en_d,
							
							input											wr_trn_en,
							
																			///////READ control from decoder
							input		[3	:	0]							TXN_ID_R_d,
							input		[addr_width-1	:	0]				araddr_d,
							input		[3	:	0]							arlen_d, 
							input		[2	:	0]							arsize_d,
							input		[1	:	0]							arburst_d,
							input		[1	:	0]							arlock_d,
							input		[1	:	0]							arcache_d,
							input		[2	:	0]							arprot_d,
							
							output	[data_width-1	:	0]				rdata_d,
							output	[1	:	0]								rresp_d,
							output	[3	:	0]								rid_d,
							output											rd_rsp_en_d,
							output											r_last_d,
                     
							
							input												rd_trn_en
							

							);
							


//////////////////////////AXI WRITE CONTROL FSM MODULE ///////////////////////////

					
AXI_MASTER_WRITE__CONTROL  #(.addr_width(32), .data_width(32)) AXI_WRITE_CONTROL
						  (
						   /////////AXI Global signals clock and reset
                     	.AClk(AClk),
								.ARst(ARstn),
						
							/////////////AXI Write Address signals
								.AWID(AWID),           
								.AWADDR(AWADDR), 
								.AWLEN(AWLEN),
								.AWSIZE(AWSIZE),
								.AWBURST(AWBURST),
								.AWVALID(AWVALID),
								.AWLOCK(AWLOCK),
								.AWCACHE(AWCACHE),
								.AWPROT(AWPROT),
								.AWREADY(AWREADY),
							
							
							////////AXI Write Data channel signals
								.WID(WID),   
								.WSTRB(WSTRB),
								.WDATA(WDATA),
								.WLAST(WLAST),
								.WVALID(WVALID),
								.WREADY(WREADY),   
							
							/////////AXI Write Response  channel signals
								.BID(BID),
								.BRESP(BRESP),
								.BVALID(BVALID),
								.BREADY(BREADY),
							
		//////////////////////////////Decoder Interface signals////////////////////////////
		              		.awaddr_d(awaddr_d),
								.TXN_ID_W_d(TXN_ID_W_d),
								.awburst_d(awburst_d),
								.awlen_d(awlen_d),
								.awsize_d(awsize_d),
								.awlock_d(awlock_d),
								.awcache_d(awcache_d),
								.awprot_d(awprot_d),
							   
								.wdata_d(wdata_d),			
								.wstrb_d(wstrb_d),
								.wvalid_d(wvalid_d),
							
								.bresp_d(bresp_d),
								.bid_d(bid_d),
								//.bvalid(bvalid),
								.wr_rsp_en_d(wr_rsp_en_d),
								.wr_trn_en(wr_trn_en)
							);


/////////////////////AXI READ FSM MODULE////////////////////////////////////


AXI_MASTER_READ_Control	#(.addr_width(32), .data_width(32)) AXI_READ_CONTROL
						 (
						   /////////AXI Global signals clock and reset
								.AClk(AClk),
								.ARst(ARstn),
						/////////////////////////////AXI INTERFACE//////////////////////////////////////////////	
						/////////AXI READ CHannel signals
					
								.ARID(ARID),           
								.ARADDR(ARADDR), 
								.ARLEN(ARLEN),
								.ARSIZE(ARSIZE),
								.ARBURST(ARBURST),
								.ARVALID(ARVALID),
								.ARLOCK(ARLOCK),
								.ARCACHE(ARCACHE),
								.ARPROT(ARPROT),
								.ARREADY(ARREADY),
						  
							
							/////////AXI READ Data signals
								.RDATA(RDATA),
								.RRESP(RRESP),
								.RLAST(RLAST),
								.RID(RID),
								.RVALID(RVALID),
								.RREADY(RREADY),
							
							
							
						
							
		//////////////////////////////Decoder Interface signals////////////////////////////
		               	.araddr_d(araddr_d),
								.TXN_ID_R_d(TXN_ID_R_d),
								.arburst_d(arburst_d),
								.arlen_d(arlen_d),
								.arsize_d(arsize_d),
								.arlock_d(arlock_d),
								.arcache_d(arcache_d),
								.arprot_d(arprot_d),
							
								.rdata_d(rdata_d),			
								.rresp_d(rresp_d), 
								.rid_d(rid_d),
								.rd_rsp_en_d(rd_rsp_en_d),
								.r_last_d(r_last_d),
								.rd_trn_en(rd_trn_en)
							
							);
							










endmodule

-----------------------------------------------------------------------------


`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company				:		 
// Engineer				: 	
// 
// Create Date			:    13:57:02 08/09/2022 
// Design Name			:	  AXI Master Interface Design	 
// Module Name			:    AXI_MASTER_READ_Control 
// Project Name		: 
// Target Devices		: 
// Tool versions		: 
// Description			: 
//
// Dependencies		: 
//
// Revision				: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module AXI_MASTER_READ_Control	#(parameter  addr_width=32, 
											  parameter  data_width=32
						               )
						 (
						   /////////AXI Global signals clock and reset
                     input							AClk,
							input							ARst,
						/////////////////////////////AXI INTERFACE//////////////////////////////////////////////	
						/////////AXI READ CHannel signals
						   output	[3	:	0]								ARID,
							output	[addr_width-1	:	0]				ARADDR,
							output	[3	:	0]								ARLEN,
							output	[2	:	0]								ARSIZE,
							output	[1	:	0]								ARBURST,
							output											ARVALID,
							input												ARREADY,
							output	[1	:	0]								ARLOCK,
							output	[1	:	0]								ARCACHE,
							output	[2	:	0]								ARPROT,
							
							/////////AXI READ Data signals
							input		[data_width-1	:	0]				RDATA,
							input		[1	:	0]								RRESP,
							input												RLAST,
							input		[3	:	0]								RID,
							input												RVALID,
							output											RREADY,
							
							
							
						
							
		//////////////////////////////Decoder Interface signals////////////////////////////
		
																				//////Read Address and Control information from Decoder
		               input		[addr_width-1	:	0]				araddr_d,
							input		[3	:	0]								TXN_ID_R_d,
							input		[1	:	0]								arburst_d,
							input		[3	:	0]								arlen_d,
							input		[2	:	0]								arsize_d,
							input		[1	:	0]								arlock_d,
							input		[1	:	0]								arcache_d,
							input		[2	:	0]								arprot_d,
							
																				/////Read DATA and Response to Decoder
							output	[data_width-1	:	0]				rdata_d,						
							output	[1	:	0]								rresp_d, 
							output	[3	:	0]								rid_d,
							output											rd_rsp_en_d,
							output	reg									r_last_d,
							
							input												rd_trn_en
							
							);
							
							

reg			[addr_width-1	:	0]				ar_addr;        
reg			[3	:	0]								ar_len;  
reg			[3	:	0]								ar_id;  
reg			[2	:	0]								ar_size;
reg			[1	:	0]								ar_burst;
reg			[1	:	0]								arlock;   
reg			[1	:	0]								arcache;
reg			[2	:	0]								arprot;
reg													ar_valid;
reg													ar_ready;

reg			[addr_width-1	:	0]				rd_addr;
reg													ar_valid_t;

reg			[data_width-1	:	0]				r_data;			
reg			[3	:	0]								r_id;
reg													r_last;
reg													r_valid;
reg													r_ready;

reg			[1	:	0]								r_resp;   
reg													r_ready_t;
reg													rd_rsp_en;

wire			[7	:	0]								BL;

reg			[addr_width-1	:	0]				araddr_r;     
reg			[7	:	0]								TXN_ID_R_r;
reg			[1	:	0]								arburst_r;
reg			[7	:	0]								arlen_r;
reg			[2	:	0]								arsize_r;
reg			[1	:	0]								arlock_r;
reg			[1	:	0]								arcache_r;
reg			[2	:	0]								arprot_r;   
reg			[data_width-1	:	0]				r_data_r;	
reg			[7	:	0]								r_id_r;
reg			[1	:	0]								r_resp_r;
reg													rd_rsp_en_r;

reg			[7	:	0]								beat_cnt;
reg			[7	:	0]								beat_cnt_reg;
reg													rd_trn_en_reg;

reg													address_en;
reg													data_en;
reg													beat_cnt_en;



//////////BURST TYPES
localparam	[1	:	0]								Fixed_Burst		=		2'b00;
localparam	[1	:	0]								INCR_Burst		=		2'b01;
localparam	[1	:	0]								Wrap_Burst		=		2'b10;


localparam	[7	:	0]								Max_burst_len	=		8'hff;  //////256 for AXI 4
																							  //////16 for AXI 3
																							  
reg 			[2	: 	0]								pst,nst;

localparam	[1	:	0]								Idle				=		2'b00;
localparam	[1	:	0]								Addr_st			=		2'b01;
localparam	[1	:	0]								Data_st			=		2'b10;

//////////////////////////////////////
//////final AXI R CHANNEL OUTPUTS
///
assign		ARID			=			ar_id;						 				
assign		ARADDR		=			ar_addr;		
assign		ARLEN			=			ar_len;
assign		ARSIZE		=			ar_size;		
assign		ARBURST		=			ar_burst;
assign		ARVALID		=			ar_valid;
assign		ARLOCK		=			arlock;
assign		ARCACHE		=			arcache;
assign		ARPROT		=			arprot;
assign		RREADY		=			r_ready;

////////////////////////////////////////////////READ DATA and Response to Decoder
assign      rresp_d		=			r_resp_r;
assign		rid_d			=			r_id_r[3:0];
assign		rd_rsp_en_d	=			rd_rsp_en_r;
assign		rdata_d		=			r_data_r;



//////////////////////////////////////////////////////////////////
/////register the input address and burst controls
//////
always @(posedge AClk)
begin
   if(!ARst)
	  begin
	    araddr_r				<=		{addr_width{1'bz}};
		 TXN_ID_R_r				<=		8'bz;
		 arburst_r				<=		2'bz;
		 arlen_r					<=		8'bz;
		 arsize_r				<=		3'bz;
		 arlock_r				<=		2'bz;
		 arcache_r				<=		2'bz;
		 arprot_r				<=		3'bz;
		 
		 r_last_d				<=		1'b0;

		 
	  end
	 else
	  begin
		 araddr_r				<=		araddr_d;     
		 TXN_ID_R_r				<=		TXN_ID_R_d;
		 arburst_r				<=		arburst_d;
		 arlen_r					<=	arlen_d;
		 arsize_r				<=		arsize_d;
		 arlock_r				<=		arlock_d;
		 arcache_r				<=		arcache_d;
		 arprot_r				<=		arprot_d;
														//////////RLAST registering
		 r_last_d				<=		RLAST;

			  
	  end
end

assign	BL					=		arlen_r	+	8'h01;			////burst length

always @(posedge AClk)
begin
   if(!ARst)
	  rd_trn_en_reg		<=			  1'b0;
	  else
	    begin
		   if(rd_trn_en)
			  rd_trn_en_reg		<=			  1'b1;
			  else
			  rd_trn_en_reg		<=			  1'b0;
		 end
end

///////////fsm sequenctial stage  
always @(posedge AClk)
begin
   if(!ARst)
	  pst				<=				Idle;
	  else
	  pst				<=				nst;
end

/////////////////next state logic ///
always @(pst,ARREADY,RID,RRESP,RVALID,RLAST,ar_valid,r_ready,rd_trn_en_reg,beat_cnt)
begin
   nst = Idle;
   case(pst)
	2'b00			:	begin														///idle   
	                
	                if(rd_trn_en_reg==1'b1)
						   nst			=		Addr_st;
							else 
							nst			=		Idle;
	               end
						
	2'b01			:	begin										
																/////read Address state ///check the ARREADY  
						 if(ar_valid && ARREADY)
						     nst			=		Data_st;
							  else
							  nst			=		Addr_st;	
						 							  
	
						    
	               end	
	

	2'b10			:	begin							///read DATA state//////receive single rdata or Burst rdata 
	                   
							 if((beat_cnt>1) && RVALID && (!RLAST))
									nst			=		Data_st; 
								else  if(RLAST )
									nst			=		Addr_st;
								
	               
						
						
						end	


						
	default		:	begin
								nst			=		Idle;
	               end	
 endcase						
end

///////////////////////////////////////FSM OUTPUT LOGIC
always @(posedge AClk)
begin
if(!ARst)
begin

		 ar_addr				<=		{addr_width{1'bz}};
		 ar_id				<=		8'bz;
		 ar_burst			<=		2'bz;
		 ar_len				<=		8'bz;
		 ar_size				<=		3'bz;
		 arlock				<=		2'bz;
		 ar_valid			<=		1'b0;
		 arcache				<=		2'bz;
		 arprot				<=		3'bz;
		 r_ready				<=		1'b0;
		 
		 r_data_r			<=		{data_width{1'bz}};
		 r_id_r				<=		8'bz;
		 r_resp_r			<=		2'bz;
		 rd_rsp_en_r		<=		1'b0;
		 
end
else
 begin
   case(pst)
	2'b00			:	begin														
	                ar_addr				<=		{addr_width{1'bz}};
						 ar_id				<=		8'bz;
						 ar_burst			<=		2'bz;
						 ar_len				<=		8'bz;
						 ar_size				<=		3'bz;
						 arlock				<=		2'bz;
						 ar_valid			<=		1'b0;
						 arcache				<=		2'bz;
						 arprot				<=		3'bz;
						 r_ready				<=		1'b0;
						 
						 r_data_r			<=		{data_width{1'bz}};
						 r_id_r				<=		8'bz;
						 r_resp_r			<=		2'bz;
						 rd_rsp_en_r		<=		1'b0;
						 
						 
	               end
						
	2'b01			:	begin							
	
						 ar_addr				<=		araddr_r;
						 ar_id				<=		{4'b0,TXN_ID_R_r};
						 ar_burst			<=		arburst_r;
						 ar_len				<=		arlen_r;
						 ar_size				<=		arsize_r;
						 arlock				<=		arlock_r;
						 ar_valid			<=		1'b1;
						 arcache				<=		arcache_r;
						 arprot				<=		arprot_r;
						 r_ready				<=		1'b0;
						 r_data_r			<=		{data_width{1'bz}};
						 r_id_r				<=		8'bz;
						 r_resp_r			<=		2'bz;
						 
						    
	               end	

	               
	2'b10			:	begin						/////receive single rdata or burst rdata 
	                
						 ar_addr				<=		{addr_width{1'bz}};
						 ar_id				<=		8'bz;
						 ar_burst			<=		2'bz;
						 ar_len				<=		8'bz;
						 ar_size				<=		3'bz;
						 arlock				<=		2'bz;
						 ar_valid			<=		1'b0;
						 arcache				<=		2'bz;
						 arprot				<=		3'bz;
						 r_ready				<=		1'b1;
						 
						 
				   if(RVALID && (beat_cnt>0))
						begin
  						 r_data_r			<=		RDATA;
						 r_id_r				<=		RID;
						 r_resp_r			<=		RRESP;
						 rd_rsp_en_r		<=		1'b1;
						end
					 else
					   begin
					    r_data_r			<=		r_data_r;
						 r_id_r				<=		r_id_r;
						 r_resp_r			<=		r_resp_r;
						 rd_rsp_en_r		<=		1'b0;
						end 
										
						
						
						end	
					
	
						
	default		:	begin
								ar_addr				<=		{addr_width{1'bz}};
								ar_id					<=		8'bz;
								ar_burst				<=		2'bz;
								ar_len				<=		8'bz;
								ar_size				<=		3'bz;
								arlock				<=		2'bz;
								ar_valid				<=		1'b0;
								arcache				<=		2'bz;
								arprot				<=		3'bz;
								r_ready				<=		1'b0;
		 
								r_data_r				<=		{data_width{1'bz}};
								r_id_r				<=		8'bz;
								r_resp_r				<=		2'bz;  
								rd_rsp_en_r			<=		1'b0;
	               end	
 endcase						
end
end


  
////////Burst Beat counter logic for handling INCR or FIxed with respective RVALID and RRESP signal from AXI slave
always @(posedge AClk)
begin
if(!ARst)
  beat_cnt			<=		8'h0;
 else
   begin
	if(pst==Addr_st)
	  beat_cnt			<=		BL;
	  else
	  if(pst==Data_st)
	   begin
	    if(( (!RLAST)&& RVALID) && (beat_cnt>0))
		   beat_cnt		<=		beat_cnt - 8'h01;
		else
		   beat_cnt		<=		beat_cnt;
		end 
		 else 
		   beat_cnt		<=		0;
	end
end


endmodule

--------------------------------------------------

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    10:31:47 08/09/2022 
// Design Name: 
// Module Name:    AXI_MASTER_WRITE__CONTROL 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module AXI_MASTER_WRITE__CONTROL #(parameter  addr_width=32, 
								   parameter  data_width=32, 			/////data width 8,16,32,64,....1024 bits
								   parameter  strobe_width =(data_width/8)
											  
						               )
						 (
						   /////////AXI Global signals clock and reset
                            input							AClk,
							input							ARst,
						/////////////////////////////AXI INTERFACE//////////////////////////////////////////////	
							/////////////AXI Write Address signals
							output	[3	:	0]								AWID,           
							output	[addr_width-1	:	0]				    AWADDR, 
							output	[3	:	0]								AWLEN,
							output	[2	:	0]								AWSIZE,
							output	[1	:	0]								AWBURST,
							output											AWVALID,
							output	[1	:	0]								AWLOCK,
							output	[1	:	0]								AWCACHE,
							output	[2	:	0]								AWPROT,
							input											AWREADY,
							
							
							////////AXI Write Data channel signals
							output	[3	:	0]								WID,   
							output	[strobe_width-1	:	0]			        WSTRB,
							output	[data_width-1		:	0]			    WDATA,
							output											WLAST,
							output											WVALID,
							input											WREADY,   
							
							/////////AXI Write Response  channel signals
							input	[3	:	0]							    BID,   
							input	[1	:	0]							    BRESP,
							input											BVALID,
							output											BREADY,
							
		//////////////////////////////Decoder Interface signals////////////////////////////
																		//////////write address and control information from decoder
		                    input		[addr_width-1	:	0]				awaddr_d,
							input		[3	:	0]							TXN_ID_W_d,
							input		[1	:	0]							awburst_d,
							input		[3	:	0]							awlen_d,
							input		[2	:	0]							awsize_d,
							input		[1	:	0]							awlock_d,
							input		[1	:	0]							awcache_d,
							input		[2	:	0]							awprot_d,
							
																		////////////////////write data and strobe from decoder
							input		[data_width-1		:	0]			wdata_d,			
							input		[strobe_width-1	:	0]			    wstrb_d,
							input                                           wvalid_d,
														
							                                   /////////////response to decoder
							output	[1	:	0]								bresp_d, 
							output	[3	:	0]								bid_d,
							//output                                          bvalid,
							output											wr_rsp_en_d,
							
							input											wr_trn_en
							
							
    );

reg			[addr_width-1	:	0]				    aw_addr;        
reg			[7	:	0]								aw_len;  
reg			[7	:	0]								aw_id;  
reg			[2	:	0]								aw_size;
reg			[7	:	0]								burst_size;
reg			[1	:	0]								aw_burst;
reg			[1	:	0]								awlock;   
reg			[1	:	0]								awcache;
reg			[2	:	0]								awprot;
reg													aw_valid;
reg													aw_ready;

reg			[addr_width-1	:	0]				    wr_addr;
reg													aw_valid_t;

reg			[data_width-1		:	0]			    w_data;
reg			[strobe_width-1	:	0]			        w_strb;			
reg			[3	:	0]								w_id;
reg													w_last;
reg													w_valid;
reg													w_valid_t;
reg													w_ready;

reg			[1	:	0]								b_resp;   
reg			[3	:	0]								b_id;
reg													b_valid;
reg													b_ready;
reg													b_ready_t;
reg													wr_rsp_en;

wire		[7	:	0]							    BL;

reg			[addr_width-1	:	0]				    awaddr_r;     
reg			[3	:	0]								TXN_ID_W_r;
reg			[1	:	0]								awburst_r;
reg			[7	:	0]								awlen_r;
reg			[2	:	0]								awsize_r;
reg			[2	:	0]								awsize_reg;
reg			[1	:	0]								awlock_r;
reg			[1	:	0]								awcache_r;
reg			[2	:	0]								awprot_r;
reg			[strobe_width-1	:	0]			        w_strb_r;   
reg			[strobe_width-1	:	0]			        w_strb_reg;
reg			[255	:	0]				            w_data_r;
reg			[data_width-1	:	0]				    w_data_r1;	
wire		[data_width-1	:	0]				    w_data_r2;
reg			[data_width-1	:	0]				    w_data_reg;	
reg                                                 w_last_reg;


reg			[7	:	0]								beat_cnt;
reg			[7	:	0]								beat_cnt_reg;
reg													wr_trn_en_reg;

reg													address_en;
reg													data_en;
reg													beat_cnt_en;
reg                                                 shift_decoder_data;
integer                                             j;

//Internal write data buffer signals
reg[31:0]											mem_buffer[255:0];
wire  												wr_en;
wire 												rd_en;
wire[31:0]											wdata_buffer= 32'b0;
reg[31:0]                                           rdata_buffer;
reg[7:0]                                            wr_ptr;
reg[7:0]											rd_ptr;
wire												fifo_full;
wire												fifo_empty;
reg[7:0]											buffer_count;



//////////BURST TYPES
localparam	[1	:	0]								Fixed_Burst		=		2'b00;
localparam	[1	:	0]								INCR_Burst		=		2'b01;
localparam	[1	:	0]								Wrap_Burst		=		2'b10;



localparam	[7	:	0]								Max_burst_len	=		8'hff;  			//////256 for AXI 4
																										//////16 for AXI 3
																							  
reg 		[2	: 	0]							    pst,nst;

localparam	[2	:	0]								Idle			=		3'b000;
localparam	[2	:	0]								Addr_st			=		3'b001;
localparam	[2	:	0]								Data_st			=		3'b010;
localparam	[2	:	0]								Resp_st			=		3'b011;


//////////////////////////////////////
//////final AXI WRITE CHANNEL OUTPUTS
///
assign		AWID		=			aw_id;						 				
assign		AWADDR		=			aw_addr;		
assign		AWLEN		=			aw_len;
assign		AWSIZE		=			aw_size;		
assign		AWBURST		=			aw_burst;
assign		AWVALID		=			aw_valid;
assign		AWLOCK		=			awlock;
assign		AWCACHE		=			awcache;
assign		AWPROT		=			awprot;
assign		WID			=			w_id;	
assign		WSTRB		=			w_strb;
assign		WDATA		=			w_data_reg;
assign		WLAST		=			w_last;
assign		WVALID		=			w_valid_t;
assign		BREADY		=			b_ready;
assign      bresp_d		=			b_resp;
assign		bid_d		=			b_id[3:0];
assign		wr_rsp_en_d	=			wr_rsp_en;





//////////////////////////////////////////////////////////////////
/////register the input address and burst controls
//////
always @(posedge AClk or negedge ARst)
begin
   if(!ARst)
	  begin
	     awaddr_r				<=		{addr_width{1'bz}};
		 TXN_ID_W_r				<=		8'bz;
		 awburst_r				<=		2'bz;
		 awlen_r				<=		8'bz;
		 awsize_r 				<=		3'bz;
		 awlock_r				<=		2'bz;
		 awcache_r				<=		2'bz;
		 awprot_r				<=		3'bz;
		 w_strb_r				<=		{strobe_width{1'b0}};   	
		 
	  end
	 else
	  begin
		 awaddr_r				<=		awaddr_d;     
		 TXN_ID_W_r				<=		TXN_ID_W_d;
		 awburst_r				<=		awburst_d;
		 awlen_r				<=		awlen_d;
		 awsize_r				<=		awsize_d;
		 awlock_r				<=		awlock_d;
		 awcache_r				<=		awcache_d;
		 awprot_r				<=		awprot_d; 
         w_strb_r				<=		wstrb_d;
         
	  end
end

//........................................................................
//store the incoming decoder data in a synchronous fifo buffer
//........................................................................

always @(posedge AClk  or negedge ARst)
begin
    if(!ARst)begin
		wr_ptr <= 8'h00;
		//wr_en  <= 1'b0;		
	end else begin		
		if(wr_en == 1'b1 && !fifo_full)begin
			wr_ptr <= wr_ptr + 1;
			mem_buffer[wr_ptr] <= wdata_buffer;			
		end 		
	end
end
always @(posedge AClk  or negedge ARst)
begin
    if(!ARst)begin
		rd_ptr <= 1'b0;
		//rd_en  <= 1'b0;		
	end else begin
		
		if(rd_en == 1'b1 && !fifo_empty)begin
			rd_ptr <= rd_ptr + 1;
			rdata_buffer <= mem_buffer[rd_ptr];			
		end
	end
end
always @ (posedge AClk or negedge ARst)
begin 
    if (!ARst) begin
		buffer_count <= 0;
	end else begin
		case ({wr_en,rd_en})
			2'b10 : buffer_count <= buffer_count + 1;
			2'b01 : buffer_count <= buffer_count - 1;
			default : buffer_count <= buffer_count;
                        
					
		endcase
	end
end	
assign wr_en = (wvalid_d == 1'b1 )? 1'b1: 1'b0;
assign rd_en = (shift_decoder_data == 1'b1 && rd_ptr==0) ? 1'b1 : (shift_decoder_data == 1'b1 && WREADY && rd_ptr>0)? 1'b1: 1'b0;	
assign fifo_full = (buffer_count == 255) ? 1'b1 : 1'b0;
assign fifo_empty = (buffer_count == 0) ? 1'b1 : 1'b0 ;

//.............................................................................................................
//.............................................................................................................


assign	BL					    =		awlen_r +	8'h01;			////burst length


///////////////////////wdata with strobe muxing 
genvar n;
generate
		for (n = 0; n < strobe_width; n = n + 1)
    begin
        assign w_data_r2[(8*n)+7 : (8*n)] = (w_strb_r[n] == 1'b1) ? rdata_buffer[(8*n)+7 : (8*n)] : w_data_r1[(8*n)+7 : (8*n)];
    end
endgenerate

/////////////////////////////////register the wstrobe mux out
always @(posedge AClk or negedge ARst)
begin
    if(!ARst)
	   w_data_r1		<=		{data_width{1'bz}};
	else
	   w_data_r1		<=		w_data_r2;
end

	  

/////////////////////////////checking awsize from decoder and align the strobe with wdata
///INCR_Burst,Wrap_Burst

always @(w_data_r2, w_strb_r, awburst_r, awsize_reg, w_data_reg, w_strb_reg, awsize_r)
begin
	if((awburst_r==INCR_Burst) || (awburst_r==Wrap_Burst))
		begin
		
		case(awsize_r)
		
		3'b000		:	begin											///size 8 bit
											awsize_reg			=		3'b000;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
						
		3'b001		:	begin											///size 16 bit
											awsize_reg			=		3'b001;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
						
		3'b010		:	begin											///size 32 bit
											awsize_reg			=		3'b010;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
		3'b011		:	begin											///size 64 bit
											awsize_reg			=		3'b011;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
		3'b100		:	begin											///size 128 bit
											awsize_reg			=		3'b100;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
						
		3'b101		:	begin											///size 256 bit
											awsize_reg			=		3'b101;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
						
		3'b110		:	begin											///size 512 bit
											awsize_reg			=		3'b110;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
		3'b111		:	begin											///size 1024 bit
											awsize_reg			=		3'b111;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
						end
        default		:  begin
											awsize_reg			=		3'b010;
											w_data_reg			=		w_data_r2;
											w_strb_reg			=		w_strb_r;
		               end
		endcase
	 end
         else begin
        awsize_reg = 3'b010; 
        w_data_reg = w_data_r2; 
        w_strb_reg = w_strb_r; 
    end
				
	end
	
always @(posedge AClk or negedge ARst) begin
    if(!ARst)
	  wr_trn_en_reg		<=			  1'b0;
    else begin
		if(wr_trn_en)
			wr_trn_en_reg		<=			  1'b1;
		else
			wr_trn_en_reg		<=			  1'b0;
	end
end



///////////fsm sequenctial stage  
always @(posedge AClk or negedge ARst)
begin
   if(!ARst)
	  pst				<=				Idle;
   else
	  pst				<=				nst;
end

/////////////////next state logic ///
always@(beat_cnt,pst,AWREADY,WREADY,BID,BRESP,BVALID,aw_valid,w_valid,w_valid_t,b_ready,wr_trn_en_reg)
begin
   case(pst)
	3'b000		:	begin														///idle state 
	                    shift_decoder_data =      1'b0;
	                    if(wr_trn_en_reg==1'b1)
						   nst			=		Addr_st;
						else 
						   nst			=		Idle;
	               end
						
	3'b001		:	begin										
						shift_decoder_data =      1'b0;										/////write Address state ///check the AWREADY  
						if(AWREADY)
						     nst			=		Data_st;
						else
							 nst			=		Addr_st;	
						 							  
	
						    
	               end	
	

	3'b010		:	begin							///write DATA state//////send first wdata or Burst data and asser wvalid
	                    shift_decoder_data =      1'b1;
						if(beat_cnt>1) begin
							nst			=		Data_st;
							shift_decoder_data =      1'b1;
						end else begin 
							nst			=		Resp_st;
                            shift_decoder_data =      1'b0;								
                        end							
						
						
					end	


	3'b011		:	begin							///write Response state//////check the bvalid and response
	                   
	                    if(b_ready && BVALID)  
						begin
							if(wr_trn_en_reg==1'b1)
								nst			=		Addr_st;
							else
								nst			=		Idle;
						end else
								nst			=		Resp_st;
                                                                shift_decoder_data = 1'b0;									
					    
	                end
						
	default		:	begin
						nst			=		Idle;
                                                shift_decoder_data = 1'b0;
	                end	
 endcase						
end

///////////////////////////////////////FSM OUTPUT LOGIC
always @(posedge AClk or negedge ARst)begin
    if(!ARst) begin

		 aw_addr			<=		{addr_width{1'bz}};
		 aw_id				<=		8'bz;
		 aw_burst			<=		2'bz;
		 aw_len				<=		8'bz;
		 aw_size			<=		3'bz;
		 awlock				<=		2'bz;
		 aw_valid			<=		1'b0;
		 awcache			<=		2'bz;
		 awprot				<=		3'bz;
		 w_strb				<=		{strobe_width{1'bz}};
		 w_data				<=		{data_width{1'bz}};
		 w_id				<=		8'bz;
		 b_id				<=		8'bz;
		 w_valid_t			<=		1'b0;
		 w_valid			<=		1'b0;
		  
		 b_ready			<=		1'b0;
		 wr_rsp_en			<=		1'b0;		 
		 
    end else  begin
        case(pst)
	    Idle		:	begin														
	                     aw_addr			<=		{addr_width{1'bz}};
						 aw_id				<=		8'bz;
						 aw_burst			<=		2'bz;
						 aw_len				<=		8'bz;
						 aw_size			<=		3'bz;
						 awlock				<=		2'bz;
						 aw_valid			<=		1'b0;
						 awcache			<=		2'bz;
						 awprot				<=		3'bz;
						 w_data				<=		{data_width{1'bz}};
						 w_strb				<=		{strobe_width{1'bz}};
						 w_id				<=		8'bz;
                         w_valid_t			<=		1'b0;
						 w_valid			<=		w_valid_t;
						  
						 b_ready			<=		1'b0;
						 wr_rsp_en			<=		1'b0;						 
						 						 
//						 beat_cnt			<=		8'b0;
						 
	               end
						
	    Addr_st		:	begin							
	
						 aw_addr			<=		awaddr_r;
						 aw_id				<=		TXN_ID_W_r;
						 aw_burst			<=		awburst_r;
						 aw_len				<=		awlen_r;
						 aw_size			<=		awsize_reg;
						 awlock				<=		awlock_r;
						 aw_valid			<=		1'b1;
						 awcache			<=		awcache_r;
						 awprot				<=		awprot_r;
						 w_data				<=		{data_width{1'bz}};
						 w_id				<=		8'bz;
						 w_valid_t			<=		1'b0;
						 w_valid			<=		w_valid_t;
						  
						 b_ready			<=		1'b0;						 
						    
	               end	

	               
		Data_st		:	begin						/////send first wdata in burst or single data and assert wvalid
	                
						 aw_addr			<=		{addr_width{1'bz}};
						 aw_id				<=		8'bz;
						 aw_burst			<=		2'bz;
						 aw_len				<=		8'bz;
						 aw_size			<=		3'bz;
						 awlock				<=		2'bz;
						 aw_valid			<=		1'b0;
						 awcache			<=		2'bz;
						 awprot				<=		3'bz;
						 //w_valid_t			<=		1'b1;
						 w_data				<=		w_data_reg; 
						 
						 w_id				<=		TXN_ID_W_r;
						 w_strb				<=		w_strb_reg;
						 b_ready			<=		1'b0;
						 wr_rsp_en			<=		1'b0;
						 
						if(beat_cnt>8'h01)begin
						   w_valid_t				<=		1'b1;
						   w_valid                  <=    w_valid_t;
						end else begin
						   w_valid_t				<=		1'b0;  
						   w_valid                  <=  w_valid_t;
						end	
					end	
					
		Resp_st		:	begin																///write response output
	                    
						w_data				<=		{data_width{1'bz}};
						w_id				<=		8'bz;

						w_valid_t			<=		1'b0;
						w_valid             <=     w_valid_t;
						b_ready				<=		1'b1;

	
	                    if(BVALID && b_ready) begin
							b_resp			<=		BRESP;
							b_id			<=		BID;
							wr_rsp_en		<=		1'b1;
						end else begin
							b_resp			<=		b_resp;
							b_id			<=		b_id;
							wr_rsp_en		<=		1'b0;
						end
					end
						
		default		:	begin
								aw_addr				<=		{addr_width{1'bz}};
								aw_id				<=		8'bz;
								aw_burst			<=		2'bz;
								aw_len				<=		8'bz;
								aw_size				<=		3'bz;
								awlock				<=		2'bz;
								aw_valid			<=		1'b0;
								awcache				<=		2'bz;
								awprot				<=		3'bz;
								w_data				<=		{data_width{1'bz}};
								w_strb				<=		4'bz;
								w_id				<=		8'bz;
								w_valid_t			<=		1'b0;
								w_valid				<=		w_valid_t;
								b_ready				<=		1'b0;
								wr_rsp_en			<=		1'b0;
						end	
		endcase						
	end
end

///////////////////////////////////wlast generation
always @(pst,beat_cnt)begin
	if((pst==3'b010) && (beat_cnt==1))
		w_last		<=		1'b1;
	else
		w_last		<=		1'b0;
end
always @(posedge AClk or negedge ARst)
begin
	if(!ARst)
		w_last_reg <= 1'b0;
	else
		w_last_reg <= w_last;
end	
  
////////Burst Beat counter logic for handling INCR or FIxed with respective Wready signal from AXI slave
always @(posedge AClk or negedge ARst)
begin
	if(!ARst)
		beat_cnt		<=		8'h0;
	else  begin
	if(pst==Addr_st)
	  beat_cnt			<=		BL;
	else
		if(pst==Data_st)begin
			if(WREADY && (beat_cnt>0))
			     beat_cnt	<=		beat_cnt - 8'h01;
		    else
		         beat_cnt		<=		beat_cnt;
		end else 
		   beat_cnt		<=		0;
	end
end

endmodule

------------------------------------------------------------------------------

module my_decoder #  (
					parameter  data_wid = 32,
	                parameter  adr_wid  = 32,
					parameter  id_wid   = 4,
					parameter  len_wid  = 4,
					parameter  siz_wid  = 3,
					parameter  bst_wid  = 2,
					parameter  loc_wid  = 2,
					parameter  cach_wid = 2,
					parameter  prot_wid = 3,
					parameter  strb_wid = 4
				  )
                 (
                   input                       clk,
                   input                       rst_n,			   
				   
                   //FIFO Interface signals
                   input                       fifo_empty,
				   input [127:0]               fifo_rdata,
				   output reg  	               read_enable,
				   
                   input                       fifo_full,				   
				   output                      write_enable,
				   output [127:0]              fifo_wdata,
				   output reg          write_data,
				   
				   //address phase packet decoded signals
				   output reg                  wr_trn_en,
		           output reg                  rd_trn_en,
				   
				   output reg [adr_wid-1:0]    awaddr,
                   output reg [id_wid-1:0]     txn_id_w,
                   output reg [bst_wid-1:0]    awburst,
                   output reg [len_wid-1:0]    awlen,

                   output reg [siz_wid-1:0]    awsize,
                   output reg [loc_wid-1:0]    awlock,
                   output reg [cach_wid-1:0]   awcache,
                   output reg [prot_wid-1:0]   awprot,
				   
				   output reg [adr_wid-1:0]    araddr,
                   output reg [id_wid-1:0]     txn_id_r,
                   output reg [bst_wid-1:0]    arburst,
		           output reg [len_wid-1:0]    arlen,
		           output reg [siz_wid-1:0]    arsize,
                   
		           output reg [loc_wid-1:0]   arlock,
                   output reg [cach_wid-1:0]   arcache,
                   output reg [prot_wid-1:0]   arprot,
				   
				   //data phase packet decoded signals
				   output reg [data_wid-1:0]   wdata,
                   output reg [strb_wid-1:0]   wstrb,
				   output reg                  wvalid,
				   
				   //read  data and response signals from AXI4 Master
				   input [id_wid-1:0]          rid,
                   input [data_wid-1:0]        rdata,
                   input [1:0]                 rresp,
				   input                       rlast,
				   input                       rd_rsp_en,
				   
				   //write response signals from AXI4 master
				   input [1:0]                 bresp,
                   input [id_wid-1:0]          bid,
				   input                       wr_rsp_en
				   
		   );
		   
//......................................................		   
//...........parameter declaration...................
//......................................................
		   
localparam IDLE            = 3'b000; 
localparam FIFO_RD   	   = 3'b001; 
localparam WR_PKT_DEC      = 3'b010;
localparam WR_PKT_DEC_1    = 3'b011;
localparam RD_PKT_DEC      = 3'b100; 
localparam RD_PKT_DEC_1    = 3'b101;

//......................................................
//........... Internal signals...................
//.......... FIFO-decoder interface..............
//......................................................

reg 				fifo_empty_d1;
wire                sop_detected;
reg                 eop_detected;

reg[2:0]            present_state;
reg[2:0]            next_state;

reg                 decode_wr_pkt;
reg                 decode_rd_pkt; 
integer             i, k;
				
reg[11:0]           wr_count;
reg[127:0]          wdata_int;
reg    				extract_56bit_data;
reg					extract_64bit_data;
reg					extract_120bit_data;
reg					extract_128bit_data;
reg                 decode_wr_pkt_reg;
reg					decode_wr_pkt_reg1;
reg                 incr_wr_cnt;
reg                 wvalid_reg;
wire                write_enable_int;
wire[127:0]         fifo_wdata_int;


//...................................................................................................		   
// Read the  address/data phase packet from the write fifo	
// There are two address phase packets. 1)write address phase packets 2)read address phase packets
// There is one data phase packet : write data phase packet
//......... Register fifo empty........................
//...................................................................................................

always @ (posedge clk or negedge rst_n) begin
	if(!rst_n)begin
		fifo_empty_d1 <= 1'b1;		
	end else begin
		fifo_empty_d1 <= fifo_empty;		
	end
end
//..............................................................
//.........detect sop..................
//..............................................................
	
assign sop_detected = (present_state == WR_PKT_DEC || present_state == RD_PKT_DEC)? 1'b0:(fifo_rdata[127:120] == 8'hAA);

//..............................................................
//........detect eop............... 
//..............................................................

always @(*)begin
		eop_detected = 1'b0;	
		for(i=0; i<16; i=i+1) begin:loop			  
			if(fifo_rdata[i*8+:8]== 8'h53) begin
				eop_detected = 1'b1;
				disable loop;
			end if(present_state == IDLE)
			    eop_detected = 1'b0;
		end	
	
end
//...............................................................
//.........control state machine................ 
//...............................................................

always @ (posedge clk or negedge rst_n)  begin 
    if (rst_n == 1'b0) begin
      present_state <= IDLE;
    end else begin
      present_state <= next_state;
    end
end

always @(*) begin
    read_enable = 1'b0;	
	wr_trn_en = 1'b0;
	rd_trn_en = 1'b0;
    decode_rd_pkt = 1'b0;
    decode_wr_pkt = 1'b0;
    incr_wr_cnt = 1'b0;
    extract_56bit_data = 1'b0;
    extract_64bit_data = 1'b0;
    extract_120bit_data = 1'b0;
    extract_128bit_data = 1'b0;
	
	case(present_state)
		IDLE: begin
				decode_rd_pkt= 1'b0;
				decode_wr_pkt = 1'b0;
				wr_trn_en = 1'b0;
				rd_trn_en = 1'b0;
				incr_wr_cnt = 1'b0;
				extract_56bit_data = 1'b0;
				extract_64bit_data = 1'b0;
				extract_120bit_data = 1'b0;
				extract_128bit_data = 1'b0;
								
				if( fifo_empty_d1) begin
					next_state = IDLE;
					read_enable = 1'b0;
				end else begin
					next_state = FIFO_RD;
					read_enable = 1'b1;
				end	
			  end
		FIFO_RD:begin  
		            
					if(sop_detected == 1'b1 ) begin
						if(fifo_rdata[63:56]== 8'h00 && fifo_rdata[55:48]== 8'h53) begin
							next_state = RD_PKT_DEC;
							rd_trn_en = 1'b1;							 
						end else begin
							next_state = WR_PKT_DEC;
							wr_trn_en = 1'b1;							 
						end
					end else begin
						next_state = FIFO_RD;       
					end
					
				end
		WR_PKT_DEC: begin		             
		              decode_wr_pkt = 1'b1; 					
					  if(eop_detected == 1'b1 && fifo_empty_d1) begin                        
						read_enable = 1'b0;
						extract_56bit_data = 1'b1;
						if(wr_count < 12'h2) begin
							next_state = WR_PKT_DEC;
                            incr_wr_cnt = 1'b1;							
						end else begin
							next_state = IDLE;
							incr_wr_cnt = 1'b0;
						end
					  end else begin					    
					    extract_64bit_data = 1'b1;
						if(wr_count < 12'h2) begin
							next_state = WR_PKT_DEC;
							incr_wr_cnt = 1'b1;
						end else begin
							next_state = WR_PKT_DEC_1;
							incr_wr_cnt = 1'b0;
							read_enable = 1'b1;
						end	
					  end
					end
					
		WR_PKT_DEC_1: begin
						read_enable = 1'b0;
						decode_wr_pkt = 1'b0;
						extract_56bit_data = 1'b0;
						extract_64bit_data = 1'b0;
						if(eop_detected == 1'b1) begin							
							extract_128bit_data = 1'b0;
							if(wr_count == 8'h4) begin
								next_state = IDLE;
								extract_120bit_data = 1'b0;
								incr_wr_cnt = 1'b0;
							end else begin
								next_state = WR_PKT_DEC_1;
								extract_120bit_data = 1'b1;
								incr_wr_cnt = 1'b1;
							end	
						end else begin
							extract_128bit_data = 1'b1;
							extract_120bit_data = 1'b0;
							incr_wr_cnt = 1'b1;
							next_state = WR_PKT_DEC_1;
							if(wr_count == 8'h4) begin							   
							   read_enable = 1'b1;
							   incr_wr_cnt = 1'b0;
							   extract_128bit_data = 1'b0;
							end   
						end
						
					  end
		RD_PKT_DEC: begin
					  decode_rd_pkt = 1'b1;					    
					  if(eop_detected == 1'b1 && fifo_empty_d1) begin
                        next_state = IDLE;	
					  end else begin
					    next_state = FIFO_RD; 
					  end
					end
		default: next_state = IDLE;	
	endcase   
end  

//.......................................................................................
//decode the write address/data phase packets and send the decoded fields at the output	
//.......................................................................................
   
always @ (posedge clk or negedge rst_n) begin 
    if (rst_n == 1'b0) begin
		txn_id_w     <= {id_wid{1'b0}};
        awaddr       <= {adr_wid{1'b0}};
        awlen        <= {len_wid{1'b0}};
		awsize       <= {siz_wid{1'b0}};
        awburst      <= {bst_wid{1'b0}};
	    awlock       <= {loc_wid{1'b0}};
	    awcache      <= {cach_wid{1'b0}};
	    awprot       <= {prot_wid{1'b0}};
	    wstrb        <= {strb_wid{1'b0}};
		wdata 		 <= {data_wid{1'b0}};
		k 			 <= 0;	
		wvalid 		 <= 1'b0;	
		wvalid_reg   <= 1'b0;
		//wvalid_reg1  <= 1'b0;
		decode_wr_pkt_reg  <= 1'b0;
		decode_wr_pkt_reg1 <= 1'b0;
	    	
	end else begin
		decode_wr_pkt_reg <= decode_wr_pkt;
		decode_wr_pkt_reg1 <= decode_wr_pkt_reg;
		//wvalid_reg1 <= wvalid_reg;
		if(decode_wr_pkt == 1'b1) begin
			txn_id_w     <=  fifo_rdata[119:116];
			awaddr       <=  fifo_rdata[115:84];
			awlen        <=  fifo_rdata[83:80];
			awsize       <=  fifo_rdata[79:77];
			awburst      <=  fifo_rdata[76:75];
			awlock       <=  fifo_rdata[74:73];
			awcache      <=  fifo_rdata[72:71];
			awprot       <=  fifo_rdata[70:68];
			wstrb        <=  fifo_rdata[67:64];
			if(k==0) begin
				wdata <= wdata_int[31:0];
				k <= 1;
				wvalid <= wvalid_reg;
				wvalid_reg <= 1'b1;
			end else if(k < 8)begin
				k <= k+1;
				wdata_int <= wdata_int >> 32;
				wdata <= wdata_int[31:0];
				wvalid <= wvalid_reg;
				wvalid_reg <= 1'b1;
			end else begin
				k <= 0;
				wvalid <= wvalid_reg;
				wvalid_reg <= 1'b0;
			end
			
		end	else begin
			if(extract_120bit_data || extract_128bit_data) begin
				if(k < 32)begin
					k <= k+1;
					wdata_int <= wdata_int >> 32;
					wdata <= wdata_int[31:0];
					wvalid <= wvalid_reg;
					wvalid_reg <= 1'b1;
				end else begin
					k <= 0;
					wvalid <= wvalid_reg;
					wvalid_reg <= 1'b0;
				end	
			end else begin
				k <= 0;
				wvalid <= wvalid_reg;
				wvalid_reg <= 1'b0;
				wdata <= 32'h0;
			end
		end
	end
end
always @(*)	begin
            wdata_int    <= {128{1'b0}};
            if(extract_56bit_data == 1'b1) begin
				wdata_int        <=  {fifo_rdata[63:8]};
			end else if(extract_64bit_data== 1'b1) begin
				wdata_int        <=  {fifo_rdata[63:0]};
			end else if(extract_120bit_data == 1'b1) begin
				wdata_int        <=  {fifo_rdata[127:8]};
			end else if(extract_128bit_data == 1'b1) begin
				wdata_int        <=  {fifo_rdata[127:0]};
			end 
end
always @ (posedge clk or negedge rst_n) begin 
    if (rst_n == 1'b0) begin
	   wr_count <= 12'h0;
	end else begin
		if(incr_wr_cnt == 1'b1) begin
			wr_count <= wr_count + 1;
		end else begin
            wr_count <= 12'h0;
	    end
	end
end

//.......................................................................
//generate write response packets and write them into the read_fifo
//.......................................................................

write_response_handler wresp(	.clk(clk),
								.rst_n(rst_n),
								.wr_rsp_en(wr_rsp_en),
							    .bid(bid),
							    .bresp(bresp),
								.fifo_full(fifo_full),				   
								.write_enable(write_enable_int),
								.fifo_wdata(fifo_wdata_int)
							);
							
assign write_enable = 	write_enable_int;
assign fifo_wdata = fifo_wdata_int;						


//...................................................................................
//decode the read address phase packets and send the decoded fields at the output
//...................................................................................

always @ (posedge clk or negedge rst_n) begin 
    if (rst_n == 1'b0)begin
		txn_id_r     <= {id_wid{1'b0}};
        araddr       <= {adr_wid{1'b0}};
        arlen        <= {len_wid{1'b0}};
		arsize       <= {siz_wid{1'b0}};
        arburst      <= {bst_wid{1'b0}};
	    arlock       <= {loc_wid{1'b0}};
	    arcache      <= {cach_wid{1'b0}};
	    arprot       <= {prot_wid{1'b0}};
	end else begin
		if(decode_rd_pkt) begin
			txn_id_r     <=  fifo_rdata[119:116];
			araddr       <=  fifo_rdata[115:84];
			arlen        <=  fifo_rdata[83:80];
			arsize       <=  fifo_rdata[79:77];
			arburst      <=  fifo_rdata[76:75];
			arlock       <=  fifo_rdata[74:73];
			arcache      <=  fifo_rdata[72:71];
			arprot       <=  fifo_rdata[70:68];		
		end
	end
end	



endmodule


------------------------------------------------------------

module design_fifo # 
(
	parameter WIDTH =128,
	parameter DEPTH =4096
)
(
//global signals
input clk,
input rst,

//write fifo signals
//input from CPU
input wr_en,
input [WIDTH-1:0]wr_data,
//input from decoder 
input READ_ENABLE,
//outputs to decoder
output [WIDTH-1:0]READ_DATA,
output FIFO_EMPTY,
//output to CPU
output full,

// read fifo signals
// input from CPU
input rd_en,
//inputs from decoder
input [WIDTH-1:0]WRITE_DATA,
input WRITE_ENABLE,
//output to decoder
output FIFO_FULL,
//output to CPU
output [WIDTH-1:0]rd_data,
output empty

);
// Module Instantiations
// sync fifo

sync_fifo  write_fifo (
	.clk(clk),
	.rst(rst),
	.wr_en(wr_en),
	.wr_data(wr_data),
	.rd_en(READ_ENABLE),
	.rd_data(READ_DATA),
	.empty(FIFO_EMPTY),
	.full(full)

);

sync_fifo  read_fifo (
	.clk(clk),
	.rst(rst),
	.rd_en(rd_en),
	.rd_data(rd_data),
	.wr_en(WRITE_ENABLE),
	.wr_data(WRITE_DATA),
	.empty(empty),
	.full(FIFO_FULL)
);

endmodule

	










	





























